"""
malware_room.py:
Trace a malware process tree and find the exfil pid.
"""
import json
from collections import defaultdict, deque
from base_room import BaseRoom

class MalwareLabRoom(BaseRoom):
    """"""
    def __init__(self, start_pid = 132):
        """Initialize the Malware Lab room with its name, description, and items."""
        desc = (
            f"A process tree is stored in proc_tree.jsonl. "
            f"start your trace from PID {start_pid} and find a path that ends with an "
            "exfil command (curl or scp)."
        )
        super().__init__("Malware lab", desc , ["proc_tree.jsonl"])
        self.start_pid = start_pid

    def _is_exfil(self, cmd: str) -> bool:
        """Return True when the process command looks like an exfiltration attempt (curl or scp)."""
        if not cmd:
            return False
        lower = cmd.lower()
        return "curl" in lower or "scp" in lower

    def _parse_jsonl(self, path):
        """Load the process tree JSONL file and skip malformed rows."""
        records = []
        skipped = 0

        try:
            with open(path, encoding="UTF-8") as file:
                lines = file.readlines()
        except FileNotFoundError:
            return ' "proc_tree.jsonl" can not be found.'

        for line in lines:
            line = line.strip()
            try:
                payload = json.loads(line)
            except json.JSONDecodeError:
                skipped += 1
                continue

            pid = payload.get("pid")
            ppid = payload.get("ppid")
            cmd = payload.get("cmd")

            records.append({"pid": pid, "ppid": ppid, "cmd": cmd})

        return records, skipped

    def _build_graph(self, recordes):
        """Build child adjacency lists plus a PIDâ†’command lookup table."""
        children = defaultdict(list)
        pid_cmd = {}

        for record in recordes:
            pid = record["pid"]
            ppid = record["ppid"]
            cmd = record["cmd"]

            if pid not in children:
                children[pid] = []
            if ppid != 0:
                children[ppid].append(pid)

            pid_cmd[pid] = cmd

        return children, pid_cmd

    def _dfs_find_path(self, start_pid, children, pid_cmd, path=None, visited=None):
        """Depth-first traversal looking for any exfil path from the start PID."""
        if path is None:
            path = [start_pid]
        if visited is None:
            visited = set()

        visited.add(start_pid)

        if self._is_exfil(pid_cmd[start_pid]):
            return path

        for child in children[start_pid]:
            if child in visited:
                continue

            path.append(child)
            result = self._dfs_find_path(child, children, pid_cmd, path, visited)
            if result is not None:
                return result
            path.pop()

        return None

    def _bfs_find_path(self, start_pid, children, pid_cmd):
        """Breadth-first traversal to locate the shortest exfil path."""
        queue = deque([start_pid])
        visited = set()
        parent = {start_pid: None}

        while queue:
            current = queue.popleft()

            cmd = pid_cmd[current]
            if self._is_exfil(cmd):
                path = []
                node = current
                while node is not None:
                    path.append(node)
                    node = parent[node]
                return list(reversed(path))

            for child in children[current]:
                if child in visited:
                    continue
                visited.add(child)

                queue.append(child)
                parent[child] = current

        return None

    def inspect(self, item, player, logger):
        """
        Inspect the given item and extract a token from a command process tree.

        Args:
            item (str): The name of the item to inspect (proc_tree.jsonl).
            player (Player): The player instance to store the token in.
            logger (Logger): The logger instance for recording actions.

        Returns:
            str: A message indicating the result of the inspection.
        """
        if item != "proc_tree.jsonl":
            return f"No such item: {item}"

        records, skipped = self._parse_jsonl("./data/proc_tree.jsonl")
        logger.log(f"Skipped lines: {skipped}")
        children, pid_cmd = self._build_graph(records)

        path = self._dfs_find_path(132, children, pid_cmd)
        if path is None:
            path = self._bfs_find_path(132, children, pid_cmd)

        if path is None:
            return "No exfil path found from start PID."

        terminal_pid = path[-1]
        cmd = pid_cmd.get(terminal_pid, "")


        path_str = "->".join(str(p) for p in path)
        logger.log(f"TOKEN[PID]={terminal_pid}")
        logger.log(f"EVIDENCE[PID].PATH=[{path_str}]")
        logger.log(f"EVIDENCE[PID].CMD=\"{cmd}\"")

        player.add_token("PID", str(terminal_pid))


        return f"Token extracted: {terminal_pid}"

from .base_room import BaseRoom
from collections import defaultdict, deque
import json

class MalwareLabRoom(BaseRoom):
    def __init__(self, start_pid = 132):
        desc = (
            f"A process tree is stored in proc_tree.jsonl. "
            f"start your trace from PID {start_pid} and find a path that ends with an "
            "exfil command (curl or scp)."
        )
        super().__init__("Malware lab", desc , ["proc_tree.jsonl"])
        self.start_pid = start_pid
        
    def _is_exfil(self, cmd: str) -> bool: 
        if not cmd:
            return False
        lower = cmd.lower()
        return "curl" in lower or "scp" in lower
    
    def _parse_jsonl(self, path):
        """"
        Parse a JSON-lines file containing process information.
        Returns:
            tuple: (records_list, skipped_count, error_message)
                   -records_list: list of dicts with 'pid', 'ppid', 'cmd'
                   -skipped_count: number of malformed lines
                   -error_message: None if successful, error string if file missing
                   
        """
        records = []
        skipped = 0
        
        try:
            with open(path) as file:
                lines = file.readlines()
        except FileNotFoundError:
            return ' "proc_tree.jsonl" can not be found.'
        
        for line in lines:
            line = line.strip()
            try:
                payload = json.loads(line)
            except json.JSONDECODEError:
                skipped += 1   
                continue
            
            pid = payload.get("pid")
            ppid = payload.get("ppid") 
            cmd = payload.get("cmd")
            
            records.append({"pid": pid, "ppid": ppid, "cmd": cmd})
            
        return records, skipped
    
    def _build_graph(self, recordes):
        children = defaultdict(list)
        pid_cmd = {}

        for record in recordes:
            pid = record["pid"]
            ppid = record["ppid"]
            cmd = record["cmd"]

            if pid not in children:
                children[pid] = []
            if ppid != 0:
                children[ppid].append(pid)
            
            pid_cmd[pid] = cmd
            
        return children, pid_cmd

    def _dfs_find_path(self, start_pid, children, pid_cmd, path=None, visited=None):
        if path is None:
            path = [start_pid]
        if visited is None:
            visited = set()
        
        visited.add(start_pid)

        if self._is_exfil(pid_cmd[start_pid]):
            return path

        for child in children[start_pid]:
            if child in visited:
                continue
            
            path.append(child)
            result = self._dfs_find_path(child, children, pid_cmd, path, visited)
            if result is not None:
                return result
            path.pop()
        
        return None

    def _bfs_find_path(self, start_pid, children, pid_cmd):
        queue = deque([start_pid])
        visited = set()
        parent = {start_pid: None}

        while queue:
            current = queue.popleft()

            cmd = pid_cmd[current]
            if self._is_exfil(cmd):
                path = []
                node = current
                while node is not None:
                    path.append(node)
                    node = parent[node]
                return list(reversed(path))

            for child in children[current]:
                if child in visited:
                    continue
                visited.add(child)

                queue.append(child)
                parent[child] = current

        return None

    def inspect(self, item, player, logger):
        if item != "proc_tree.jsonl":
            return f"No such item: {item}"
        
        records, skipped = self._parse_jsonl("./data/proc_tree.jsonl")
        # logger.log(f"Records: {records}") Do we need to add that line to logs ?
        logger.log(f"Skipped lines: {skipped}")
        children, pid_cmd = self._build_graph(records)

        path = self._dfs_find_path(132, children, pid_cmd)
        if path is None:
            path = self._bfs_find_path(132, children, pid_cmd)

        if path is None:
            return "No exfil path found from start PID."
        
        terminal_pid = path[-1]
        cmd = pid_cmd.get(terminal_pid, "")


        path_str = "->".join(str(p) for p in path)
        logger.log(f"TOKEN[PID]={terminal_pid}")
        logger.log(f"EVIDENCE[PID].PATH=[{path_str}]")
        logger.log(f"EVIDENCE[PID].CMD=\"{cmd}\"")

        player.add_token("PID", str(terminal_pid))


        return f"Token extracted: {terminal_pid}"
                